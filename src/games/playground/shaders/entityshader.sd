
include {
    aglobal;
    threed;
    forwardshading;
    basicshape;
}

descriptor {
    variants {
    }
    resources {
        vec3 entityAlbedo;
        float specularStrength;
        float mandelbrotQuality;
        float bumpyness;
        float bumpScale;
    }
}

stages {
    ps {
        entry = main;
        use entityAlbedo;
        use specularStrength;
        use mandelbrotQuality;
        use bumpyness;
        use bumpScale;
    }
    vs {
        entry = main;
    }
}

vs {
    layout(location = 0) out vec3 worldPos;
#if renderPass == color_pass
    layout(location = 1) out vec3 vAlbedo;
    layout(location = 2) out vec3 normal;
    layout(location = 3) out vec4 tc_specular_mandelbrot;
    layout(location = 4) out vec3 eyeToWorld;
#endif
    void main() {
        VertexData vertexData = getVertexData(gl_VertexIndex);
        worldPos = getWorldSpacePoint(vertexData.pos).xyz;
#if renderPass == color_pass
        vAlbedo = PushConstants.entityAlbedo;
        normal = getWorldSpaceDirection(vertexData.normal).xyz;
        tc_specular_mandelbrot = vec4(vertexData.tc, PushConstants.specularStrength, PushConstants.mandelbrotQuality);
        eyeToWorld = worldPos - PushConstants.eyePos;
#endif
        gl_Position = worldToScreenSpacePoint(worldPos);
    }
}

ps {
    layout(location = 0) in vec3 worldPos;
#if renderPass == color_pass
    layout(location = 1) in vec3 vAlbedo;
    layout(location = 2) in vec3 normal;
    layout(location = 3) in vec4 tc_specular_mandelbrot;
    layout(location = 4) in vec3 eyeToWorld;

    void main() {
        vec3 albedo = vec3(vAlbedo);
        float specular = tc_specular_mandelbrot.z;
        uint iterations = uint(round(max(PushConstants.mandelbrotQuality, 0.0)));
        if (iterations > 0) {
            vec2 c = tc_specular_mandelbrot.xy * 2.0 - 1.0;
            c *= 2.0;
            c.x -= 1;
            c.y *= 0.5;
            vec2 x = vec2(0.0, 0.0);
            uint exit = 0;
            for (uint i = 0; i < iterations; ++i) {
                x = vec2(x.x*x.x - x.y*x.y, 2.0 * x.x*x.y) + c;
                if (length(x) > 2.0)
                {
                    exit = i+1;
                    break;
                }
            }
            vec3 exitColor = albedo * 0.8;
            vec3 midColor = albedo * 0.9;
            vec3 peakColor = 1.0 - (1.0-albedo)*0.6;
            if (exit == 0) {
                albedo = exitColor;
                specular = 0;
            } else {
                float f = log(float(exit)) / log(float(iterations));
                specular *= f * 0.5 + 0.5;
                if (f < 0.5) {
                    f = f*2;
                    albedo = mix(vec3(albedo), vec3(midColor), f);
                } else {
                    f = (f-0.5)*2;
                    albedo = mix(vec3(midColor), vec3(peakColor), f);
                }
            }
        }

        if (PushConstants.bumpyness > 0) {
            vec2 bumpTc = tc_specular_mandelbrot.xy * PushConstants.bumpScale;
            albedo = vec3(0.0, 0.0, 0.0);
            albedo.x = perlinNoise(bumpTc, 2);
        }
        outColor = lightToColor(shadePixel(normalize(eyeToWorld), worldPos, normalize(normal), albedo, specular, 1.0));
    }
#else
    void main() {
        outColor = vec4(0.0, 0.0, 0.0, 1.0);
    }
#endif

}
