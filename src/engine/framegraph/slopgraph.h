#pragma once

#include <cstdint>
#include <limits>

class SlopGraph
{
 public:
    using SlopNodeId = uint32_t;
    static constexpr SlopNodeId INVALID_SLOP_NODE = std::numeric_limits<SlopNodeId>::max();

    struct NodeInfos
    {
        // TODO record existing delay due to latency reduction
        uint64_t startTimeNs;
        uint64_t endTimeNs;
        int64_t slopNs;  // within the node's work time
    };

    virtual uint32_t getNodeCount() const = 0;
    virtual NodeInfos getNodeInfos(SlopNodeId node) const = 0;
    virtual uint32_t getChildCount(SlopNodeId node) const = 0;
    virtual uint32_t getChild(SlopNodeId node, uint32_t index) const = 0;
    // true for nodes than are not dependent, but run on the same thread right after the given node
    virtual bool isImplicitDependency(SlopNodeId node, uint32_t index) const = 0;

    struct FeedbackInfo
    {
        int64_t directSlopNs = 0;  // generated by this node
        int64_t totalSlopNs = 0;   // directSlop + recursive slop
        SlopNodeId implicitChild = INVALID_SLOP_NODE;
        // if the implicit child didn't exists, direct slop would increase by this much
        // if it's too high, it's recommended to separate the two nodes onto different threads or reorder them
        int64_t extraSlopWithoutImplicitChildNs = 0;
    };

    virtual void feedBack(SlopNodeId node, const FeedbackInfo& info) = 0;

    FeedbackInfo calculateSlop(SlopNodeId sourceNode, SlopNodeId targetNode, bool feedbackNodes);

 protected:
    ~SlopGraph() = default;

 private:
    struct NodeData
    {
        FeedbackInfo feedbackInfo;
        uint32_t dependenceCount = 0;
        bool ordered = false;
    };
};
