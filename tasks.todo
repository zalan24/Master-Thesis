Get a triangle on screen:
    ☐ Shader manager
    ☐ Finish descriptors
    ☐ Validate synchronization using the link in sources
    ☐ Create an api consts header file and put all const values there (barrier limits, tracker limits, etc.)
    ✔ Add logging @done (3/28/2021, 12:39:53 PM)
    ✔ Discard image data using undefined oldLayout in transition (add a cmd for this, or add this to the barrier struct???) @done (3/13/2021, 7:52:00 PM)
    ☐ Check out "streamline trace": https://github.com/KhronosGroup/Vulkan-Samples/blob/master/samples/performance/render_passes/render_passes_tutorial.md
    ☐ Optimize push constant ranges: generate_resource_object() in compile.cpp
    ☐ Mesh shading: https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPipelineInputAssemblyStateCreateInfo.html
    ☐ Specialization constants: https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#pipelines-specialization-constants
    ☐ Sample shading (pipeline creation)
    ☐ Alpha coverage (pipeline creation)
    ☐ Depth bounds test (pipeline creation)
    ☐ Blend constants (pipeline creation)
    ☐ Color blending (pipeline creation)
    ☐ Debug markers: https://www.saschawillems.de/blog/2016/05/28/tutorial-on-using-vulkans-vk_ext_debug_marker-with-renderdoc/
        ☐ Actually use the VK_EXT_debug_utils for this: https://www.khronos.org/registry/vulkan/specs/1.1-extensions/pdf/vkspec.pdf#%5B%7B%22num%22%3A30297%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C0%2C740.55%2Cnull%5D
    ☐ Performance queries: VK_KHR_performance_query
    ☐ Push constants
        ☐ Create a some system, where the position of headers can be specified
        ☐ Inside the scope of this system, these positions would be reserved for all shaders even if they don't use a header
    ☐ Check how command pool usages / family queue usages are synced. Maybe not necessary?
    ☐ Conditional rendering: https://www.khronos.org/news/permalink/tutorial-vulkan-conditional-rendering
    ☐ Shaders
        ☐ Var types:
            ☐ Command buffer fix: values only defined within a command buffer, like grid cell transformation for grid rendering
            ☐ Material parameters: values set for a material, but not changed at runtime (usually, maybe for editing)
            ☐ Dynamic global variables: camera matrix for eg.
            ☐ Material resources (textures and buffers)
            ☐ Global resources
    ☐ drv::drv_assert shouldn't use std::strings, because it causes dynamic memory allocations...
    ☐ Add dynamic memory allocations to report file
        ☐ Also add avg amount of memory in framemem
        ☐ And maybe something about stackmem

    ☐ Performance capture
        ✔ cpu node dependencies @done (8/6/2021, 1:44:16 PM)
            ✔ depended and dependent nodes should be displayed when hovering a node @done (8/6/2021, 1:44:05 PM)
            ✔ Ones that actually delayed the current node or were actually delayed should be highlighted @done (8/6/2021, 1:44:13 PM)
        ✔ Resource locks @done (8/6/2021, 1:44:20 PM)
            ✔ Add a new time point, when the depended nodes are complete, but the resources not yet @done (8/6/2021, 1:44:19 PM)
        ✔ swapchain acquire and present should be displayed @done (8/6/2021, 1:44:23 PM)
        ✔ Execution queue @done (8/7/2021, 10:28:59 AM)
            ✔ Hovering a node should highlight it's execution time range @done (8/7/2021, 8:59:46 AM)
            ✔ Display execution packages and somehow link them to the source node (requires node info in packages) @done (8/7/2021, 8:59:50 AM)
            ✔ Display cpu node wait on execution @done (8/7/2021, 10:28:57 AM)
        ✔ Device queue @done (8/7/2021, 10:58:59 AM)
            ✔ Display gpu complete waits @done (8/7/2021, 10:58:57 AM)
            ✔ Display gpu node waits @done (8/7/2021, 10:58:58 AM)
        ☐ Deal with slop
            ✔ Implement slop graph for framegraph @done (8/28/2021, 12:06:42 PM)
            ✔ Create one slop graph object in graph building and reuse when needed @done (8/28/2021, 12:06:46 PM)
            ✔ FrameGraph should have a function for slop calculation, called in readback end, right before perf capture @done (8/28/2021, 12:06:54 PM)
            ✔ Node history should store slop info. Updated by slop graph's feedback @done (8/28/2021, 12:06:59 PM)
            ✔ Perf capture should contain the calculated slop for the source node (as a global reducible latency) @done (8/28/2021, 12:07:11 PM)
            ☐ Somehow warn about nodes, that have a high extra slop due to implicit dependency
            ☐ ??? Display per node slops on capture ???
        ☐ Finalize
            ✔ Show screenshot @done (9/12/2021, 2:02:39 PM)
            ☐ Styling
                ✔ Width should fit window (and react to resize window) @done (9/12/2021, 12:52:58 PM)
                ✔ Padding around texts @done (9/12/2021, 12:53:01 PM)
                ☐ No transparency upon hovering
                ☐ Colors
                ✔ Improve vsync lines @done (9/12/2021, 1:05:47 PM)
            ☐ Add all necessary information


    ☐ Document
        ☐ What is latency?
        ☐ Why is it important?
        ☐ How to measure it?
            ☐ Show and explain LDAT
            ☐ Show and explain internal software latency measurement
            ☐ Explain what's different, what's missing in software latency (hardware latency, input that is pressed between input samplings have extra latency)
            ☐ Explain why software latency is used (We can't really help the other aspects of latency; it can be measured in realtime in dynamic scenes)
        ☐ Introduce example app
            ☐ Explain why physics doesn't depend on input sampling
        ☐ Where does it come from?
            ☐ Explanation of cpu / execution queue / gpu pipeline
        ☐ Naive solutions to eliminate it
        ☐ Related work
            ☐ COD & Reflex
            ☐ What this project adds (to both COD and reflex)
        ☐ Latency reduction algorithm used here (without perf measurementes: sleepTime = ...)
            ☐ Explain unlimited/limited/discretized modes
        ☐ How to obtain such values from a completed frame
            ☐ Naive solutions and why they don't work (eg measuring cpu work time, disregarding dependencies and async calculations)
                ☐ Use visual examples
            ☐ Introduce frameGraph based representation
            ☐ Show the slopGraph's algorithm and how it calculates different values
                ☐ Try to use as many references to graph algorithms / theories as possible
            ☐ Show that this is the correct solution
        ☐ How to predict future values and what to predict
            ☐ The frame end should be predicted, not the slop. Explain why
        ☐ Results
        ☐ Future work

    ☐ Replace resource descriptions in framegraph node queries with resource descriptor providers (which only determines physical resources after node's dependency wait)


Cleanup & other:
    ☐ Remove useless common driver stuff (drv/common)
    ✔ Use abstract driver class instead of function pointer table @done (1/26/2021, 11:31:13 AM)
    ✔ Maybe use a single large stack memory (thread local) instead of local ones: LOCAL_MEMORY_POOL_DEFAULT(pool)? @done (2/28/2021, 3:50:11 PM)


Questions:
    ✔ Query 16 queue and use 1 vs Query 1 queue and use 1 @done (1/18/2021, 12:28:09 PM)
        -> allocation cost
        -> can have extra perf cost as well. Don't do it
    ✔ Synchronize between two queue after every command (semaphores), but no actual waiting happens @done (1/18/2021, 12:28:30 PM)
        -> semaphore overhead is negligible
    ✔ 16 draw calls on 16 queues vs 16 draw calls on 1 queue (sync for depth test and sync for color write) @done (1/18/2021, 12:29:45 PM)
        -> no point in separation, card already runs in parallel. Set up render passes properly though
        -> cs and transfer can be separate
    ✔ How vk submit waits on semaphores, where stages are provided (command buffers might contain a lot of pipelines) @done (1/18/2021, 12:37:58 PM)
        -> all commands wait until that stage on the semaphore
    ✔ 100 commands on same buffer vs on separate buffers @done (1/18/2021, 12:29:18 PM)
        -> consumes memory / more api calls. Use a single buffer if possible
    ✔ Can I record commands to two separate command buffers, which share a command pool concurrently? @done (1/26/2021, 11:31:18 AM)
        -> No
    ☐ Transient command buffer vs non-transient (except for parallel execution)

    https://stackoverflow.com/questions/37575012/should-i-try-to-use-as-many-queues-as-possible

    ☐ Read: https://mynameismjp.wordpress.com/2018/06/17/breaking-down-barriers-part-3-multiple-command-processors/
    ☐ Read: https://community.arm.com/developer/tools-software/graphics/b/blog/posts/vulkan-mobile-best-practices-and-management


Resource identifiers
 * ???
Runtime stat object
 * Add structure to runtime stats (???)
    * Probably a map of resource id -> resource data
 * Add a feature flag for savig stats
 * Load / save stats (loading should consider which stats are required at runtime, only load those)
    * Save two files, one full, which is used when export stats is enabled (this will preserve previously collected data, used by shader compiler)
    * One for load only version, which only loads data, that's used in a prod version
 * Create a macro, that creates a recorder/reader object for the resource stats
 * Create a resource stat object for each command buffer automatically
Auto register resources
 * Instead of throwing an error, auto register unregistered resources based on the first access
    * Assume current ownership
    * Assume most optimal layout
    * Assume clean state (or whatever is required)
 * In a situation like this, record the current resource into the resource stats object
    * The dst state is as assumed here
    * The src state is found during execution
 * If exportation of runtime stats is enabled, add a resource usage stats object to the execution queue's command buffer data
    * The execution queue should record all resource usage into it (src usage)
External resources in render passes
 * Give a name to the render pass (and each subpass)
 * Create two resource stat objects per render pass
    * One for incoming resources
    * One for outgoing resources
 * When recording to cmd buffer, record attachment usage into the resource stats object
 * At the creation of render pass, create external dependencies based on usual usage
    * If unavailable, use something basic (auto pipeline barriers can fix it)
    * It's required to have some kind of an external barrier (at least for transitive dependency)