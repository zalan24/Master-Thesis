Get a triangle on screen:
    ☐ Modify queue manager to work with command lanes
    ☐ Implement barriers
    ☐ Implement events
    ☐ Implement graphical pipeline
    ☐ Implement render pass
    ☐ Create a frame memory allocator
        ☐ It needs to support allocation on recording thread and release in the execution thread (multiple frame memory objects?)
        ☐ Use a pool of frame mems? acquire in simulation thread, release in execution thread
    ☐ Command for reset command buffer
    ☐ Add a new thread for callbacks
        ☐ Pair of fences or events + std::function can be added to it
        ☐ Wait for fence/event execute function
    ☐ Prepare frame-graph and multi-command buffer for per-frame building and execution
        ☐ Use frame mem
        ☐ Review/rework queue selection algorithm
        ☐ Add extra info to dependencies? (for barriers and buffer grouping)
        ☐ Reuse objects, where possible (don't recreate multi command buffer)
        ☐ Nodes should create command buffers directly and later record into them
            ☐ Nodes could have a list of command buffers??? (these would be in the same synchronization unit)
        ☐ Nodes should be assigned to a command lane
        ☐ Pre-create nodes
            ☐ Some nodes should be pre-created before recording starts (these should be fairly constant nodes)
            ☐ Don't create them every frame
            ☐ These nodes need the same queues every frame (until recreation)
            ☐ Nodes can have single-time submission (recorded every frame)
            ☐ Nodes can have a fixed command buffer. For such nodes, the renderer needs to have a function to fill them (before normal render)
                ☐ If they need recreating, add their command buffer to a separate list, paired with a fence, which is added to the assigned queue
                ☐ Have a cleanup thread (or use the callback wait thread), which waits for these fences and removes objects (later different types of resources can be added)
        ☐ On-the-fly queue assignment (for command pool)
            ☐ New nodes can be added, and they get a queue dynamically
            ☐ Execution removes executed dynamic nodes
            ☐ There should be a pool of command buffers for each queue family
                ☐ If there is no available command buffer, create one
                ☐ If there is a command buffer in the pool, use it
                ☐ When removing the node: reset the command buffer, return it to the pool
                ☐ Should be concurrent
        ☐ Nodes need to be closeable (no more dependencies can be created)
        ☐ Allow partial execution of closed nodes
            ☐ Instead of actual execution, just return a queue and the command buffer
        ☐ Frame graph should be concurrent (adding nodes in one thread, partial executions in the other)
        ☐ Are semaphores needed within a single queue (events might be better)
    ☐ Execute frame graph
        ☐ When a node is complete (closed):
            ☐ Have two command buffers (or two lists if lists are used)
            ☐ Wait for the execution buffer to be empty (executed)
            ☐ Swap buffer pointers
            ☐ Execution thread will execute the execution buffer and reset it, then signal the recorder thread, that the buffer is ready to swap
        ☐ Dynamic nodes: just remove them from frame graph and then execute
        ☐ Static nodes:
            ☐ constant nodes:
                ☐ Use transient command queues and just submit the same stuff every time
            ☐ one-time nodes:
                ☐ Use the command pool as in dynamic nodes
                ☐ Move the command buffer out of the node, execute at later
    ☐ Shader manager
    ☐ Finish descriptors

Cleanup & other:
    ☐ Remove useless common driver stuff (drv/common)
    ☐ Use abstract driver class instead of function pointer table


Questions:
    ☐ Query 16 queue and use 1 vs Query 1 queue and use 1
    ☐ Synchronize between two queue after every command (semaphores), but no actual waiting happens
    ☐ 16 draw calls on 16 queues vs 16 draw calls on 1 queue (sync for depth test and sync for color write)
    ☐ How vk submit waits on semaphores, where stages are provided (command buffers might contain a lot of pipelines)
