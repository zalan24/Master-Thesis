Get a triangle on screen:
    ✔ Rework command lanes @done (1/19/2021, 11:12:55 AM)
        ✔ Command lane info contains queue infos (name, what's required, what's preferred, priority, etc.) @done (1/19/2021, 10:42:42 AM)
        ✔ When using the same queue, use the highest priority @done (1/19/2021, 10:42:45 AM)
        ✔ Try to use different queue families in a command lane @done (1/19/2021, 10:45:02 AM)
        ✔ Command lane tries to get these queues separately if possible @done (1/19/2021, 10:45:21 AM)
        ✔ Command lane will have a set of queues assigned to the names, which don't have to be unique (transfer and render queue can be the same) @done (1/19/2021, 10:45:28 AM)
        ✔ Command lanes used in the engine: @done (1/19/2021, 10:45:36 AM)
            ✔ Main @done (1/19/2021, 10:45:36 AM)
                ✔ Render (graphics queue) @done (1/19/2021, 10:45:35 AM)
                ✔ Compute (compute queue) @done (1/19/2021, 10:45:35 AM)
                ✔ DtoH (transfer queue) @done (1/19/2021, 10:45:34 AM)
                ✔ HtoD (transfer queue) @done (1/19/2021, 10:45:33 AM)
            ✔ Input @done (1/19/2021, 10:45:33 AM)
                ✔ HtoD (transfer queue) @done (1/19/2021, 10:45:32 AM)
    ✔ Modify queue manager to work with command lanes @done (1/19/2021, 11:12:08 PM)
        ✔ Have a mapping of CommandLane -> QueueName -> Queue @done (1/19/2021, 11:12:08 AM)
        ✔ Acquired queues based on this @done (1/19/2021, 11:12:08 AM)
        ✔ Remove hash based groupings (maybe some other stuff as well) @done (1/19/2021, 11:12:07 PM)
    ☐ Command buffer pool
        ✔ Initialize in engine @done (1/20/2021, 12:25:34 AM)
        ☐ CommandBuffer circulator:
            ✔ Only resetable one-time-submit command buffer are supported @done (1/22/2021, 9:25:39 PM)
            ✔ Is assigned to a family @done (1/22/2021, 9:25:43 PM)
            ✔ Have a Command pool @done (1/22/2021, 9:25:43 PM)
            ✔ The idea is that, upon cmd buffer request @done (1/22/2021, 9:25:46 PM)
                ✔ If there is an available buffer, return it @done (1/22/2021, 9:25:46 PM)
                    ✔ Prefer queues with lower index @done (1/22/2021, 9:25:47 PM)
                ✔ If not, create more command buffers @done (1/22/2021, 9:25:51 PM)
                ☐ If utilization is low for a long time, decrease the size by releasing the last X command buffers
            ✔ Upon recording the buffer, it should be sent to the execution thread with the circulator ptr @done (2/28/2021, 3:48:51 PM)
            ✔ Upon submission, give the pending buffer back to the circulator @done (2/28/2021, 3:48:53 PM)
            ✔ Dtor/close asserts/waits if there are some pending queues (that might be a problem when in a catch block...) @done (2/28/2021, 3:48:57 PM)
        ✔ Have a CommandBuffer circulator for each queue family @done (1/22/2021, 9:26:05 PM)
    ✔ Execution queue @done (2/28/2021, 3:49:10 PM)
        ✔ Create a struct which can store: (in union?) @done (1/27/2021, 10:20:31 PM)
            ✔ CommandBuffer handle @done (1/27/2021, 10:20:31 PM)
            ✔ std::function @done (1/27/2021, 10:20:32 PM)
            ✔ messages? @done (1/27/2021, 10:20:32 PM)
        ✔ Create a concurrent dequeue for this struct between recording and execution @done (1/27/2021, 10:20:34 PM)
        ✔ Execution is reading this pipe for instructions @done (1/27/2021, 10:20:36 PM)
        ✔ Execute command buffers @done (2/28/2021, 3:49:09 PM)
    ☐ Create a frame memory allocator
        ☐ It needs to support allocation on recording thread and release in the execution thread (multiple frame memory objects?)
        ☐ Use a pool of frame mems? acquire in simulation thread, release in execution thread
    ✔ Rework frame graph @done (2/28/2021, 3:49:29 PM)
    ✔ Implement barriers @done (1/27/2021, 11:38:06 AM)
    ✔ Implement timeline semaphores @done (2/28/2021, 3:49:41 PM)
    ✔ Implement events @done (1/26/2021, 11:30:31 AM)
    ☐ Implement graphical pipeline
    ☐ Implement render pass
    ☐ Command for reset command buffer
    ☐ Add a new thread for callbacks
        ☐ Pair of fences or events + std::function can be added to it
        ☐ Wait for fence/event execute function
    ☐ Shader manager
    ☐ Finish descriptors
    ✔ Add an event pool @done (3/2/2021, 9:34:57 AM)
        ✔ Use garbage system for recycling @done (3/2/2021, 9:34:57 AM)
    ☐ Resource tracking
        ☐ Image and buffer tracking info
            ✔ Images and buffers need a separate struct under vulkan api @done (3/13/2021, 8:48:37 PM)
            ☐ This struct needs to store tracking slots
                ✔ These are for parallel state tracking @done (3/13/2021, 8:48:44 PM)
                ☐ Values stored per slot
                    ☐ Common
                        ✔ Ownership @done (3/9/2021, 2:53:36 PM)
                        ✔ Usable stages (src for prev barrier) @done (3/10/2021, 11:34:17 AM)
                        ☐ Event to wait on before usage????
                    ✔ Images store data per mip level per array index (have max values for this) @done (3/11/2021, 9:20:12 PM)
                        ✔ Layout @done (3/10/2021, 9:00:26 AM)
                        ✔ Ongoing writing pipeline stages (src mask for next barrier) @done (3/9/2021, 2:55:48 PM)
                        ✔ Ongoing reading pipeline stages (src mask for next barrier for writing operations) @done (3/9/2021, 2:55:48 PM)
                        ✔ Ongoing flushing pipeline stages @done (3/9/2021, 2:55:49 PM)
                        ✔ Ongoing invalidating pipeline stages @done (3/9/2021, 2:55:50 PM)
                        ✔ Dirty access mask for availability (which access types have un-flushed memory) @done (3/9/2021, 2:57:24 PM)
                        ✔ Visibility access mask (which access types have un-flushed memory) @done (3/9/2021, 2:57:24 PM)
                        ✔ Upon writing @done (3/10/2021, 11:19:54 AM)
                            ✔ Requirements @done (3/10/2021, 10:47:39 AM)
                                ✔ Wait on flushing and invalidating stages if they are not 0 @done (3/10/2021, 10:40:35 AM)
                                ✔ Need to wait on other writes and reads (ongoing operations) @done (3/10/2021, 10:41:15 AM)
                                ✔ Correct ownership or shared access @done (3/10/2021, 10:47:36 AM)
                                ✔ Proper layout @done (3/10/2021, 10:43:45 AM)
                                ✔ Overwritten writes could be logged here for performance improvement suggestions @done (3/10/2021, 10:42:25 AM)
                            ✔ dirty access mask := writing access mask @done (3/10/2021, 10:50:00 AM)
                            ✔ Visibility mask := 0 (Memory not visible on any access type) @done (3/10/2021, 10:50:18 AM)
                            ✔ Ongoing writing := to current stages @done (3/10/2021, 10:51:28 AM)
                            ✔ Ongoing reading := 0 @done (3/10/2021, 10:51:29 AM)
                            ✔ Ongoing flushing := 0 @done (3/10/2021, 10:51:29 AM)
                            ✔ Ongoing invalidations := 0 @done (3/10/2021, 11:16:47 AM)
                            ✔ Set layout if it's changed @done (3/10/2021, 10:52:16 AM)
                        ✔ Upon reading @done (3/10/2021, 11:04:10 AM)
                            ✔ Requirements @done (3/10/2021, 11:01:21 AM)
                                ✔ Need to wait on invalidating operations @done (3/10/2021, 10:55:08 AM)
                                ✔ Dirty access mask for visibility & currentMask = currentMask (implies availability) @done (3/10/2021, 11:01:03 AM)
                                ✔ Correct ownership or shared access @done (3/10/2021, 10:57:56 AM)
                                ✔ Proper layout @done (3/10/2021, 11:01:20 AM)
                            ✔ Ongoing reading pipeline stages |= current stages @done (3/10/2021, 11:04:09 AM)
                        ✔ Upon inserting pipeline barrier @done (3/11/2021, 7:47:21 PM)
                            ✔ Parameters @done (3/11/2021, 7:36:07 AM)
                                ✔ Does it need to flush @done (3/11/2021, 7:36:04 AM)
                                ✔ Required visibility mask @done (3/11/2021, 7:36:05 AM)
                                ✔ Dst stages @done (3/11/2021, 7:36:05 AM)
                                ✔ Layout transition @done (3/11/2021, 7:36:06 AM)
                                ✔ Ownership transition @done (3/11/2021, 7:36:06 AM)
                            ✔ Handle usable mask @done (3/11/2021, 7:53:07 AM)
                            ✔ If it flushes the memory (needs to flush all access types) @done (3/11/2021, 7:45:05 AM)
                                ✔ src stages := ongoing writing stages @done (3/11/2021, 7:44:29 AM)
                                ✔ Ongoing flushing := dst stages @done (3/11/2021, 7:44:30 AM)
                                ✔ Src access mask := Dirty access mask for availability @done (3/11/2021, 7:44:43 AM)
                                ✔ Dirty access mask for availability := 0 @done (3/11/2021, 7:44:54 AM)
                                ✔ Ongoing invalidations := 0 @done (3/11/2021, 7:44:55 AM)
                            ✔ If it invalidates cache @done (3/11/2021, 7:54:20 AM)
                                ✔ Src := ongoing flushing stages OR writing stages (if it's the same barrier) @done (3/11/2021, 7:53:54 AM)
                                ✔ Ongoing invalidations |= dst stages @done (3/11/2021, 7:53:57 AM)
                                ✔ Dst access mask for pipeline barrier := required visibility mask & Dirty access mask for visibility @done (3/11/2021, 7:54:08 AM)
                                ✔ Dirty access mask for visibility ^= Dst access mask for pipeline barrier @done (3/11/2021, 7:54:18 AM)
                        ✔ Pay attention to memory layout (probably array index should be the first index, 2nd should be the mip level) @done (3/10/2021, 12:03:27 PM)
                    ☐ Buffer????
                        ☐ Have a small history of sub+resource ranges + an extra fix slot for the entire buffer (instead of arrays and mip levels)
                        ☐ Per history/fixed slot
                            ☐ A slot stores sub-resource ranges (with a fixed max number)
                            ☐ When doing on operation, find the correct slot:
                                ☐ If there is an exact match, use that
                                ☐ If not, try to create a new slot
                                ☐ If no more free slots, create a virtual slot and perform a slot merge
                            ☐ Do the exact same as for the image without the layout
                        ☐ History management
                            ☐ When accessing a slot, merge all overlapping slots into it (if the fixed slot is updated, history is cleared)
                        ☐ Slot merge
                            ☐ Calculate resulting sub-resource ranges
                                ☐ If the new slots needs to many ranges, merge the ranges
                            ☐ Find all slots in the history than conflict with this slot...
                            ☐ ... ???
                ✔ Most of the state data should be in a struct that is used by both the image and the buffer @done (3/10/2021, 1:15:36 PM)
                ✔ There is a fixed number of slots (use a define for this, could be a build option) @done (3/10/2021, 1:15:41 PM)
                ✔ Slot ids are acquired from the driver (not the resource) @done (3/10/2021, 9:26:28 AM)
                    ✔ A tracking slot = resource tracker object @done (3/10/2021, 1:37:12 PM)
                    ☐ The framegraph can reuse trackers, where there is no parallel usage (must be same queue as well)
                    ☐ Reuse as much as possible
                ☐ Placing barriers
                    ✔ Auto placed barriers: @done (3/12/2021, 9:12:28 AM)
                        ✔ Separate access function into validation and execution @done (3/11/2021, 8:44:33 PM)
                        ✔ Validation should be called before execution and it should create a pipeline barrier if necessary @done (3/12/2021, 9:12:27 AM)
                        ✔ If needed use the existing memory_sync function(s) @done (3/11/2021, 9:12:18 PM)
                        ✔ Execution will now only apply the new state, assuming correct resource state @done (3/11/2021, 9:12:25 PM)
                    ☐ Barriers are collected until the next access operation or the end of recording instead of immediate placement
                        ✔ Collect barriers per sub-resource range @done (3/13/2021, 8:48:06 PM)
                            ✔ Add some barriers states data to tracker @done (3/13/2021, 8:44:39 PM)
                        ☐ When a accessing the memory (or syncing?) flush barriers for the required sub-resource ranges
                            ✔ In this case, there should be an array of flushable barriers @done (3/13/2021, 8:45:03 PM)
                            ✔ When processing a new sub-resource range and a barriers is required for it, try to append it to one of the existing barriers or create a new barrier @done (3/13/2021, 8:45:18 PM)
                                ✔ Different barriers should be disjunct in terms dst and src stages @done (3/13/2021, 8:45:18 PM)
                            ☐ Have different options for this (applicable in release builds as well)
                                ☐ Flush only sub-resource ranges where it's actually necessary (inside requested sub-resource ranges)
                                ☐ Flush all requested sub-resource ranges, but not anymore
                                ☐ Check all sub-resource ranges of the resource and if one can be appended to an existing barrier (?dst and src masks ok?), append it
                                    ☐ Include other resources as well with pending barriers?
                                ☐ Flush all sub-resource ranges of the resource always
                                    ☐ Include other resources as well with pending barriers?
                        ☐ There should be special flush at the end of recording of a command buffer, that flushes everything in an optimized way
                    ✔ Create an enum of possible resource usages (separate for buffer and texture?) @done (3/12/2021, 9:08:10 AM)
                        ✔ Have a mapping from usage -> (pipeline stage mask, memory access mask) @done (3/12/2021, 9:08:09 AM)
                    ✔ Barriers are originally created for sub-resource ranges (later can be merged) @done (3/13/2021, 8:45:34 PM)
                    ✔ Barriers for a single sub-resource are merged @done (3/13/2021, 8:45:37 PM)
                    ☐ Barriers are flushed when accessing the memory (or doing a layout transition / ownership transfer)
                        ✔ Different layout transitions would need separate barriers @done (3/13/2021, 8:46:03 PM)
                        ☐ These could be merged with layout transition if the flushed barriers don't have a layout transition
                    ☐ Create a cmd for memory barrier
                        ☐ Input
                            ✔ Required usages @done (3/12/2021, 9:59:38 AM)
                            ✔ Resource & sub-resources @done (3/12/2021, 10:02:20 AM)
                            ☐ Ownership (could be deduced from current queue)
                            ✔ Layout transition for images (could be deduced from usage) @done (3/12/2021, 10:49:08 AM)
                        ✔ Resource needs to have a clear state regarding the selected usages @done (3/13/2021, 8:46:57 PM)
                        ✔ cmd pipeline barrier should not be exposed to the engine @done (3/12/2021, 9:58:50 AM)
                ☐ When submitting the command buffer with semaphores, states might be changed??? or not
            ☐ Create state objects for images and buffers to share state between tracking slots
                ☐ Is resource readable/writable in this linear context? (use this info in validator later)
                ☐ Object content
                    ☐ full resource state
                ☐ Have some simple initializers for this object
                ☐ Object implementation should be hidden in driver api
                ☐ Exposed initializers:
                    ☐ A couple of simple ones (full flushed, fully visible, nothing to wait on, etc.)
                    ☐ Have an initializer specifically to be used with semaphores (a signal semaphore and a wait semaphore version)
                        ☐ In this case, add the semaphore to the submit info automatically (if it's not already added)
                        ☐ If it's already added check the wait stages (in case of wait semaphore)
                        ☐ This can be handled with command buffer recorder
                        ☐ Remove manual semaphore placement???
                    ☐ Initialize by current images state
                    ☐ Have a modifier call, that can change state for a specific sub-resource range (to allow precise state definition)
                ☐ Create an init_resource function in the tracker
                    ☐ Explicit version without state info: use when resource state is not modified outside of this tracker (local resources)
                    ☐ Version with incoming state and outgoing state
                ☐ Validations
                    ☐ Tracker checks resource state against outgoing state, if it was set with the init resource (exact match is not needed)
                        ☐ Wait stage masks should be narrower than the required state probably
                        ☐ Access masks should be narrower than teh required masks probably
                        ☐ Check ownership (if resource was not actually used, it's not set...)
                    ☐ Validate the init resource is called exactly once
                    ☐ In debug mode
                        ☐ Try to build a graph of resource usage?
                        ☐ Graph could be built per resource
                        ☐ Nodes are submissions (= cmd recorder) with in/out state objects; semaphores and events
                        ☐ Edges could be built from semaphore and event usage
                        ☐ Result needs to be a flow graph
                        ☐ Edges can be checked to validate state object compatibility
                        ☐ Validate the local resources (without in/out states) are actually not used with different tracking slots / on different queues
            ☐ Sync by framegraph (registered resources)
                ☐ Try to reuse tracking ids as much as possible
                ☐ For same tracking id usage, with cpu dependency, use empty resource initializers for shared resources (enq dep implied, tracking info ok)
                ☐ For other nodes with same queue
                    ☐ Enq dep is implied, so normal barriers can be used. Declare a state object somewhere and auto use it
                    ☐ Consider using an event though (maybe optional auto event?)
                ☐ For other nodes with different queue
                    ☐ Declare basic states (layout only???)
                    ☐ Auto create semaphore based state objects and use them
                ☐ In same queue and different queue case, one (partial) state is declared by the user, the in/out states are generated to be valid
        ☐ Tracker settings
            ☐ Verbosity / assertations
                ☐ Silent fixes (warn about invalid states, nothing for suboptimal states)
                ☐ Debug (error on invalid states, error on suboptimal states)
                ☐ Barrier focus (error on everything)
            ☐ Sync options
                ☐ Default: sync when needed only, as much as needed
                ☐ Barriers are placed immediately instead of collecting and merging them
                ☐ Sync all dst stages
                    ☐ In addition Flush all
                    ☐ In addition invalidate all
                ☐ Sync all src stages
                ☐ Place barrier after each command, regardless of state

        ☐ Track resources globally
            ☐ Created resource ids in the framegraph
                ☐ Resources are resolved in every frame (first usage of the res id)
                    ☐ Multiple physical resources can be bound to a res id (eg. images from gbuffer)
                ☐ Flag for last write (after which no sync is needed for read operations)???
                    ☐ Command buffer recorder should call a command to mark the last write
                    ☐ Intended to be used with Garbage system
                ☐ Flag for different resource every frame
                    ☐ No need to sync inter frame
                    ☐ This basically means the signalling of sync objects intended for the next frame
                ☐ Flag for global sub-resource range
                    ☐ When set, the sub-resource range is also recorded at resource resolution
                    ☐ Finer sync with events
                    ☐ Extra validation is needed
                ☐ No auto sync flag
                ☐ Special semaphore supplier
                    ☐ Instead of using the auto sync system, use a custom functor/something to know when and how to sync current resource usage
                    ☐ Intended for resources that are written only once (textures, meshes) and other custom resources
            ☐ Register the resource ids in the queue -> ... and ... -> queue dependencies
                ☐ Res id
                ☐ Read/write mask
            ☐ Validate registered resource usage
            ☐ Have a method in command buffer recorder for supplying a registered resource
                ☐ supplyRegisteredResource(resId, resource, sub_resource_range, pipelineStageMask, accessMask)
                ☐ signal semaphores and events based on dependencies in framegraph
                ☐ The exact event and semaphore should be known in the waiter commands (they might be recorded earlier)
            ☐ Have a method for demanding a registered resource
                ☐ demandRegisteredResource(resId, resource, sub_resource_range, pipelineStageMask, accessMask)
                ☐ This command buffer should wait on the proper semaphores and events
                ☐ Signal events and semaphores for writing nodes
            ☐ Maybe merge these two and add a mask for reading / writing???
            ☐ In case of a recorded usage of the resource doesn't conflict, there is no need to wait
            ☐ Once a resource is resolved by the supplier node, no sync is needed to different resource values (other image was used in the last frame)
            ☐ When waiting for a registered resource by event, just add it to the local tracker and it should do the work
            ☐ If there are no depending write operations for a resource, reads may not need to signal anything???
                ☐ Later frame writes can wait on frame finish instead???
            ☐ What about missing demand or supply operations???
        ☐ Validate resource usage
            ☐ Any resource
            ☐ Only debug mode
            ☐ Track resources globally in the framegraph (same way as in command buffer recorder)
            ☐ Use a mutex for recording usage history
            ☐ Find conflicting usages
            ☐ Allowed conflicting usage:
                ☐ Inside same node and same frame (need to register nodeId and frameId)
                ☐ Usage in a node/frame which has an appropriate dependency and the resource is registered
                    ☐ Need to check dependency offset and place of usage (cpu/queue)
        ☐ Validate synchronization using the link in sources
    ☐ Create an api consts header file and put all const values there (barrier limits, tracker limits, etc.)
    ☐ Add logging
    ✔ Discard image data using undefined oldLayout in transition (add a cmd for this, or add this to the barrier struct???) @done (3/13/2021, 7:52:00 PM)

Cleanup & other:
    ☐ Remove useless common driver stuff (drv/common)
    ✔ Use abstract driver class instead of function pointer table @done (1/26/2021, 11:31:13 AM)
    ✔ Maybe use a single large stack memory (thread local) instead of local ones: LOCAL_MEMORY_POOL_DEFAULT(pool)? @done (2/28/2021, 3:50:11 PM)


Questions:
    ✔ Query 16 queue and use 1 vs Query 1 queue and use 1 @done (1/18/2021, 12:28:09 PM)
        -> allocation cost
        -> can have extra perf cost as well. Don't do it
    ✔ Synchronize between two queue after every command (semaphores), but no actual waiting happens @done (1/18/2021, 12:28:30 PM)
        -> semaphore overhead is negligible
    ✔ 16 draw calls on 16 queues vs 16 draw calls on 1 queue (sync for depth test and sync for color write) @done (1/18/2021, 12:29:45 PM)
        -> no point in separation, card already runs in parallel. Set up render passes properly though
        -> cs and transfer can be separate
    ✔ How vk submit waits on semaphores, where stages are provided (command buffers might contain a lot of pipelines) @done (1/18/2021, 12:37:58 PM)
        -> all commands wait until that stage on the semaphore
    ✔ 100 commands on same buffer vs on separate buffers @done (1/18/2021, 12:29:18 PM)
        -> consumes memory / more api calls. Use a single buffer if possible
    ✔ Can I record commands to two separate command buffers, which share a command pool concurrently? @done (1/26/2021, 11:31:18 AM)
        -> No
    ☐ Transient command buffer vs non-transient (except for parallel execution)

    https://stackoverflow.com/questions/37575012/should-i-try-to-use-as-many-queues-as-possible

    ☐ Read: https://mynameismjp.wordpress.com/2018/06/17/breaking-down-barriers-part-3-multiple-command-processors/
    ☐ Read: https://community.arm.com/developer/tools-software/graphics/b/blog/posts/vulkan-mobile-best-practices-and-management