Get a triangle on screen:
    ☐ Shader manager
    ☐ Finish descriptors
    ☐ Validate synchronization using the link in sources
    ☐ Create an api consts header file and put all const values there (barrier limits, tracker limits, etc.)
    ✔ Add logging @done (3/28/2021, 12:39:53 PM)
    ✔ Discard image data using undefined oldLayout in transition (add a cmd for this, or add this to the barrier struct???) @done (3/13/2021, 7:52:00 PM)
    ☐ Check out "streamline trace": https://github.com/KhronosGroup/Vulkan-Samples/blob/master/samples/performance/render_passes/render_passes_tutorial.md
    ☐ Optimize push constant ranges: generate_resource_object() in compile.cpp
    ☐ Mesh shading: https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPipelineInputAssemblyStateCreateInfo.html
    ☐ Specialization constants: https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#pipelines-specialization-constants
    ☐ Sample shading (pipeline creation)
    ☐ Alpha coverage (pipeline creation)
    ☐ Depth bounds test (pipeline creation)
    ☐ Blend constants (pipeline creation)
    ☐ Color blending (pipeline creation)
    ☐ Debug markers: https://www.saschawillems.de/blog/2016/05/28/tutorial-on-using-vulkans-vk_ext_debug_marker-with-renderdoc/
        ☐ Actually use the VK_EXT_debug_utils for this: https://www.khronos.org/registry/vulkan/specs/1.1-extensions/pdf/vkspec.pdf#%5B%7B%22num%22%3A30297%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C0%2C740.55%2Cnull%5D
    ☐ Performance queries: VK_KHR_performance_query
    ☐ Push constants
        ☐ Create a some system, where the position of headers can be specified
        ☐ Inside the scope of this system, these positions would be reserved for all shaders even if they don't use a header
    ☐ Check how command pool usages / family queue usages are synced. Maybe not necessary?
    ☐ Conditional rendering: https://www.khronos.org/news/permalink/tutorial-vulkan-conditional-rendering
    ☐ Shaders
        ☐ Var types:
            ☐ Command buffer fix: values only defined within a command buffer, like grid cell transformation for grid rendering
            ☐ Material parameters: values set for a material, but not changed at runtime (usually, maybe for editing)
            ☐ Dynamic global variables: camera matrix for eg.
            ☐ Material resources (textures and buffers)
            ☐ Global resources
    ☐ drv::drv_assert shouldn't use std::strings, because it causes dynamic memory allocations...
    ☐ Add dynamic memory allocations to report file
        ☐ Also add avg amount of memory in framemem
        ☐ And maybe something about stackmem

    ☐ Finish app for thesis requirements
        ✔ Fix perf metrics @done (10/2/2021, 8:45:12 PM)
        ✔ Fix push const problem @done (10/2/2021, 9:24:23 PM)
        ✔ Fix imgui??? @done (10/2/2021, 8:50:23 PM)
        ✔ Background mandelbrot should use shader var instead of interval @done (10/3/2021, 7:08:26 PM)
        ✔ Create manual workload for: before input, after input, execution (submission of main render data) & device (background mandelbrot) @done (10/3/2021, 7:16:13 PM)
            ✔ Support avg & stdDiv options for these @done (10/3/2021, 6:56:18 PM)
        ✔ Add mandelbrot to the random objects with shader var for quality @done (10/3/2021, 8:37:26 PM)
        ✔ Make it look nicer @done (10/6/2021, 12:37:05 PM)
        ✔ Add camera recorder & reply in benchmark @done (10/3/2021, 12:35:35 PM)
        ✘ Make the capture have the final look (remove record/end node for example or not) @cancelled (10/6/2021, 12:37:15 PM)
        ✔ Disable resize? @done (10/4/2021, 1:02:37 PM)
        ✔ Culling? @done (10/3/2021, 2:34:05 PM)
        ☐ Set up test scenes
        ☐ Finalize plots
        ✘ Be able to start exe without args. Double click on exe should work @cancelled (10/4/2021, 12:43:23 PM)
        ✔ Have scripts to run the exe @done (10/4/2021, 12:43:33 PM)
        ✔ Be able to specify settings file, so that each benchmark config can keep it's own engine options @done (10/4/2021, 12:43:34 PM)
        ✔ Scripted tests @done (10/4/2021, 12:57:47 PM)

    ☐ Benchmarking & tests
        ☐ Laboratory tests
            ☐ Measurements will need: all data from capture + LDAT
            ☐ Measure in configs:
                ☐ No stdDiv & heigh stdDiv
                ☐ Cpu limited (before input) & cpu limited (after input) & exec limited & gpu limited & exec + gpu limited (both accumulate delay)
                ☐ No latency reduction & normal latency reduction & fps limited & discretized low latency pool (used with no stdDiv) & high latency pool (that actually works with high stdDiv)
        ☐ Clean test
            ✔ Have one giant cube with expensive mandelbrot @done (10/7/2021, 11:33:40 AM)
            ✔ rotate camera from not seeing cube to filling the screen with it @done (10/7/2021, 11:33:46 AM)
            ✔ When object not/partly-visible, cpu>=gpu @done (10/7/2021, 11:39:09 AM)
            ✔ Accelerate rotation throughout the benchmark period @done (10/7/2021, 11:33:59 AM)
            ☐ Compare no reduction & fps limit & discretized
        ☐ Chaos
            ☐ Create a scene where gpu & cpu perf are very similar -> both cpu and gpu are saturated with work, with some variance
            ☐ Have objects with cheap mandelbrot, that are not always visible
            ☐ Use emitters
            ☐ Move the camera randomly around as expected in an fps game
            ☐ Set up latency reduction in the best way possible
            ☐ Compare no reduction & fps limit & discretized
        ☐ Take captures in every test config
        ☐ generate plots in every benchmark config


    ☐ Document
        ☐ What is latency?
        ☐ Why is it important?
        ☐ How to measure it?
            ☐ Show and explain LDAT
            ☐ Show and explain internal software latency measurement
            ☐ Explain what's different, what's missing in software latency (hardware latency, input that is pressed between input samplings have extra latency)
            ☐ Explain why software latency is used (We can't really help the other aspects of latency; it can be measured in realtime in dynamic scenes)
        ☐ Introduce example app
            ☐ Explain why physics doesn't depend on input sampling
        ☐ Where does it come from?
            ☐ Explanation of cpu / execution queue / gpu pipeline
        ☐ Naive solutions to eliminate it
        ☐ Related work
            ☐ COD & Reflex
            ☐ What this project adds (to both COD and reflex)
        ☐ Latency reduction algorithm used here (without perf measurementes: sleepTime = ...)
            ☐ Explain unlimited/limited/discretized modes
        ☐ How to obtain such values from a completed frame
            ☐ Naive solutions and why they don't work (eg measuring cpu work time, disregarding dependencies and async calculations)
                ☐ Use visual examples
            ☐ Introduce frameGraph based representation
            ☐ Show the slopGraph's algorithm and how it calculates different values
                ☐ Try to use as many references to graph algorithms / theories as possible
            ☐ Show that this is the correct solution
        ☐ How to predict future values and what to predict
            ☐ The frame end should be predicted, not the slop. Explain why
        ☐ Results
        ☐ Future work

    ☐ Replace resource descriptions in framegraph node queries with resource descriptor providers (which only determines physical resources after node's dependency wait)


Cleanup & other:
    ☐ Remove useless common driver stuff (drv/common)
    ✔ Use abstract driver class instead of function pointer table @done (1/26/2021, 11:31:13 AM)
    ✔ Maybe use a single large stack memory (thread local) instead of local ones: LOCAL_MEMORY_POOL_DEFAULT(pool)? @done (2/28/2021, 3:50:11 PM)


Questions:
    ✔ Query 16 queue and use 1 vs Query 1 queue and use 1 @done (1/18/2021, 12:28:09 PM)
        -> allocation cost
        -> can have extra perf cost as well. Don't do it
    ✔ Synchronize between two queue after every command (semaphores), but no actual waiting happens @done (1/18/2021, 12:28:30 PM)
        -> semaphore overhead is negligible
    ✔ 16 draw calls on 16 queues vs 16 draw calls on 1 queue (sync for depth test and sync for color write) @done (1/18/2021, 12:29:45 PM)
        -> no point in separation, card already runs in parallel. Set up render passes properly though
        -> cs and transfer can be separate
    ✔ How vk submit waits on semaphores, where stages are provided (command buffers might contain a lot of pipelines) @done (1/18/2021, 12:37:58 PM)
        -> all commands wait until that stage on the semaphore
    ✔ 100 commands on same buffer vs on separate buffers @done (1/18/2021, 12:29:18 PM)
        -> consumes memory / more api calls. Use a single buffer if possible
    ✔ Can I record commands to two separate command buffers, which share a command pool concurrently? @done (1/26/2021, 11:31:18 AM)
        -> No
    ☐ Transient command buffer vs non-transient (except for parallel execution)

    https://stackoverflow.com/questions/37575012/should-i-try-to-use-as-many-queues-as-possible

    ☐ Read: https://mynameismjp.wordpress.com/2018/06/17/breaking-down-barriers-part-3-multiple-command-processors/
    ☐ Read: https://community.arm.com/developer/tools-software/graphics/b/blog/posts/vulkan-mobile-best-practices-and-management


Resource identifiers
 * ???
Runtime stat object
 * Add structure to runtime stats (???)
    * Probably a map of resource id -> resource data
 * Add a feature flag for savig stats
 * Load / save stats (loading should consider which stats are required at runtime, only load those)
    * Save two files, one full, which is used when export stats is enabled (this will preserve previously collected data, used by shader compiler)
    * One for load only version, which only loads data, that's used in a prod version
 * Create a macro, that creates a recorder/reader object for the resource stats
 * Create a resource stat object for each command buffer automatically
Auto register resources
 * Instead of throwing an error, auto register unregistered resources based on the first access
    * Assume current ownership
    * Assume most optimal layout
    * Assume clean state (or whatever is required)
 * In a situation like this, record the current resource into the resource stats object
    * The dst state is as assumed here
    * The src state is found during execution
 * If exportation of runtime stats is enabled, add a resource usage stats object to the execution queue's command buffer data
    * The execution queue should record all resource usage into it (src usage)
External resources in render passes
 * Give a name to the render pass (and each subpass)
 * Create two resource stat objects per render pass
    * One for incoming resources
    * One for outgoing resources
 * When recording to cmd buffer, record attachment usage into the resource stats object
 * At the creation of render pass, create external dependencies based on usual usage
    * If unavailable, use something basic (auto pipeline barriers can fix it)
    * It's required to have some kind of an external barrier (at least for transitive dependency)